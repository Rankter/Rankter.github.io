<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA反射机制</title>
    <url>/2024/07/28/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一、Java反射机制"><a href="#一、Java反射机制" class="headerlink" title="一、Java反射机制"></a>一、Java反射机制</h2><blockquote>
<p>Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而动态操作类或对象属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。</p>
</blockquote>
<p>为什么需要JAVA反射？</p>
<p>举个例子：我们在某个程序中，需要使用<strong>实现Animal接口</strong>的Dog类，让它叫两声，叫<strong>这个动作在接口中就定义了</strong>；如果有一天，我们想Cat叫，我们是不是还要修改代码，去new一个Cat，然后把Dog换成Cat呢？然而在现实中，有很多代码的源代码你都拿不到，都修改不了；或者说，你把产品交给客户，还希望他去修改代码？</p>
<p><strong>不如这样：</strong></p>
<p>我们在编写代码的时候，只写一个动物会叫这个功能，我们利用反射创建一个类，然而反射需要的参数是一个字符串，我们将字符串存入配置文件中，这样，我们修改配置文件即可动态产生不一样的代码了，而用户，通过修改配置文件就可以了，他不需要怎么写代码（一般也不会知道）。</p>
<p><strong>使用情景：</strong></p>
<blockquote>
<p>情景一：有的类是我们在编写程序的时候无法使用new一个对象来实例化对象的。</p>
</blockquote>
<p>例如：</p>
<ul>
<li>调用来自网络的二进制.class文件，而没有其.java代码</li>
<li>注解-注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li>
</ul>
<blockquote>
<p>情景二：动态加载（可以最大限度的体现Java的灵活性，并降低类的耦合度：多态）</p>
</blockquote>
<p>有的类可以在用到时再动态加载到jvm中，这样可以减少jvm的启动时间，同时更重要的是动态的加载需要的对象（多态）。例如：</p>
<ul>
<li>动态代理-在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代方式。这时，就需要反射技术来实现了。</li>
</ul>
<p><strong>Java反射</strong>用白话文来说就是：在编译完后（固定）的还能动态操作Java对象（动态加载）</p>
<h3 id="获取类对象代码实现方式"><a href="#获取类对象代码实现方式" class="headerlink" title="获取类对象代码实现方式"></a>获取类对象代码实现方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span>     <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br></pre></td></tr></table></figure>



<h2 id="二、ClassLoader类加载"><a href="#二、ClassLoader类加载" class="headerlink" title="二、ClassLoader类加载"></a>二、ClassLoader类加载</h2><p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/u011490072/article/details/81560295">https://blog.csdn.net/u011490072/article/details/81560295</a></li>
<li><a href="https://blog.csdn.net/lioncatch/article/details/106013246">https://blog.csdn.net/lioncatch/article/details/106013246</a></li>
</ul>
<p>为什么要自己实现一个类加载器？</p>
<h3 id="2-1-类加载器的种类"><a href="#2-1-类加载器的种类" class="headerlink" title="2.1 类加载器的种类"></a>2.1 类加载器的种类</h3><p>Java有三种类加载器（面试会问）</p>
<ol>
<li>根类加载器（bootstrap class loader）</li>
<li>扩展类加载器（extension class loader）</li>
<li>应用类加载器（applicaion class loader）</li>
</ol>
<p>关系如下图所示：</p>
<p><img src="/images/daishen/img/61.png" alt="在这里插入图片描述"></p>
<p>双亲委派机制：</p>
<ul>
<li>定义：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的<strong>启动类加载器</strong>中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去加载。这个机制就叫<strong>双亲委派机制</strong>。</li>
</ul>
<p>双亲委派机制的实现：</p>
<ol>
<li>首先，检查请求的类是否已经被加载过了</li>
<li>未加载，则请求父类加载器去加载对应路径下的类，</li>
<li>如果加载不到，才由下面的子类依次去加载。</li>
</ol>
<p>例如：</p>
<ul>
<li>Java.lang.String-&gt;根加载器-&gt;扩展加载器-&gt;本地加载器</li>
</ul>
<h3 id="2-2-用户自己实现类加载器"><a href="#2-2-用户自己实现类加载器" class="headerlink" title="2.2 用户自己实现类加载器"></a>2.2 用户自己实现类加载器</h3><h4 id="1、为什么要实现自己的ClassLoader"><a href="#1、为什么要实现自己的ClassLoader" class="headerlink" title="1、为什么要实现自己的ClassLoader"></a>1、为什么要实现自己的ClassLoader</h4><ul>
<li>我们需要的类不一定存放在已经设置好的classPath下（有系统类加载器AppClassLoader加载的路径），对于自定义中class类文件的加载，我们需要自己的ClassLoader</li>
<li>有时我们不一定是从类文件中读取类，可能是从网络的输入流中读取类，这就需要做一些加密和解密操作，这就需要自己实现加载类的逻辑，当然其他的特殊处理也同样适用。</li>
<li>可以定义类的实现机制，实现类的热部署，如OSGI中的bundle模块就是通过实现自己的ClassLoader实现的。</li>
</ul>
<h4 id="2、加载class文件"><a href="#2、加载class文件" class="headerlink" title="2、加载class文件"></a>2、加载class文件</h4><p>在实现自己的类加载器之前，先来看一下<strong>双亲委派机制</strong>的代码实现逻辑；因为我们实现的ClassLoader都是继承于java.lang.ClassLoader类，父加载器都是AppClassLoader，所以在上层逻辑中依旧要保证该模型，所以一般不覆盖loadClass函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass ( String name , <span class="type">boolean</span> resolve ) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//检查指定类是否被当前类加载器加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="literal">null</span> )&#123;<span class="comment">//如果没被加载过，委派给父加载器加载</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( parent != <span class="literal">null</span> )</span><br><span class="line">                    c = parent.loadClass(name,resolve);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;<span class="keyword">catch</span> ( ClassNotFoundException e )&#123;</span><br><span class="line">                <span class="comment">//如果父加载器无法加载</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( c == <span class="literal">null</span> )&#123;<span class="comment">//父类不能加载，由当前的类加载器加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( resolve )&#123;<span class="comment">//如果要求立即链接，那么加载完类直接链接</span></span><br><span class="line">            resolveClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将加载过这个类对象直接返回</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们可以看到在<strong>父加载器不能完成加载任务</strong>时，会调用<strong>findClass(name)<strong>函数，这个就是我们自己实现的ClassLoader的查找类文件的规则，所以在继承后，我们只需要</strong>覆盖findClass()这个函数</strong>，实现我们本地加载器中的查找逻辑，而且还不会破坏双亲委派模型。</p>
<h4 id="3、加载资源文件（URL）"><a href="#3、加载资源文件（URL）" class="headerlink" title="3、加载资源文件（URL）"></a>3、加载资源文件（URL）</h4><blockquote>
<p>我们有时会用Class.getResource():URL来获取相应的资源文件。如果仅仅使用上面的ClassLoader是找不到这个资源的，相应的返回值为null</p>
</blockquote>
<p>Class.getResource()的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.net.URL <span class="title function_">getResource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        name = resolveName(name);<span class="comment">//解析资源</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> getClassLoader();<span class="comment">//获取到当前类的classLoader</span></span><br><span class="line">        <span class="keyword">if</span> (cl==<span class="literal">null</span>) &#123;<span class="comment">//如果为空，那么利用系统类加载器加载</span></span><br><span class="line">            <span class="comment">// A system class.</span></span><br><span class="line">            <span class="keyword">return</span> ClassLoader.getSystemResource(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果获取到classLoader,利用指定的classLoader加载资源</span></span><br><span class="line">        <span class="keyword">return</span> cl.getResource(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码发现Class.getResource()是通过<strong>委派给ClassLoader的getResource()实现的</strong>，所以我们来看ClassLoader对于资源文件的获取的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> URL <span class="title function_">getResource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    URL url;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        url = parent.getResource(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = getBootstrapResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">        url = findResource(name);<span class="comment">//这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>综上</strong></p>
<p>我们在创建自己的ClassLoader时只需要**覆写findClass(name)和findResource()**即可</p>
<p><strong>实现加载自定义路径下的class文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TestClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channels;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.WritableByteChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classpath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classpath)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.classpath = classpath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> getClassFile(name);</span><br><span class="line">        <span class="type">byte</span>[] classByte = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classByte = getClassBytes(fileName);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用自身加载器</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">realClass</span> <span class="operator">=</span> defineClass(<span class="literal">null</span>, classByte, <span class="number">0</span>, classByte.length);</span><br><span class="line">        <span class="keyword">if</span> (realClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;由我加载&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> realClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 委派给父类加载器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;父类加载器加载&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 获取当前操作系统下的类文件合法路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 合法的路径文件名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getClassFile</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(classpath);</span><br><span class="line">        sb.append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(name.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">                .append(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 获取指定类文件的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 类文件的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">byte</span> [] getClassBytes ( String name ) <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(name);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> fileInput.getChannel();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">WritableByteChannel</span> <span class="variable">byteChannel</span> <span class="operator">=</span> Channels.newChannel(output);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> flag;</span><br><span class="line">            <span class="keyword">while</span> ((flag = channel.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//将buffer写入byteChannel</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                byteChannel.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> ( IOException e )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;can&#x27;t read!&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        fileInput.close();</span><br><span class="line">        channel.close();</span><br><span class="line">        byteChannel.close();</span><br><span class="line">        <span class="keyword">return</span> output.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;F:\\代码审计区\\MyDemo\\Test\\target\\classes\\org\\test&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myClassLoader.loadClass(<span class="string">&quot;java.io.InputStream&quot;</span>); <span class="comment">//会有父类加载器直接加载掉，不会经过自定义的LoadClass函数</span></span><br><span class="line">            myClassLoader.loadClass(<span class="string">&quot;One&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Main</span> <span class="operator">=</span> myClassLoader.loadClass(<span class="string">&quot;Mainx&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> ( ClassNotFoundException e )&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/images/daishen/img/63.png" alt="image-20240624101338367"></p>
<p><strong>热部署和加密解密的ClassLoader实现，大同小异。只是findClass的逻辑发生改变而已</strong></p>
<p>根据以上实现的类加载器基础上，对加载class后的调用的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;F:\\代码审计区\\MyDemo\\JavaEEServlet\\src\\TestClassLoader&quot;</span>);</span><br><span class="line">        myClassLoader.loadClass(<span class="string">&quot;java.io.InputStream&quot;</span>); <span class="comment">//会有父类加载器直接加载掉，不会经过自定义的LoadClass函数</span></span><br><span class="line">        <span class="comment">//myClassLoader.loadClass(&quot;One&quot;);</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">Main</span> <span class="operator">=</span> myClassLoader.loadClass(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载class文件后如何使用</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> Main.getConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(); <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Main.getMethod(<span class="string">&quot;slefsayhello&quot;</span>); <span class="comment">//不传参</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method_1</span> <span class="operator">=</span> Main.getMethod(<span class="string">&quot;sayhello&quot;</span>,String.class); <span class="comment">//传参</span></span><br><span class="line">        method.invoke(obj);</span><br><span class="line">        method_1.invoke(obj, <span class="string">&quot;OkMain&quot;</span>); <span class="comment">//对应传入参数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/images/daishen/img/62.png" alt="image-20240624104648810"></p>
<p>Mian.class的Java测试代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayhello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hi!Hello &quot;</span>+name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slefsayhello</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hi! Hello My Dog!&quot;</span>);</span><br><span class="line">		<span class="comment">// 恶意代码</span></span><br><span class="line">		Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、Java动态代理"><a href="#三、Java动态代理" class="headerlink" title="三、Java动态代理"></a>三、Java动态代理</h2><p>所谓静态代理，顾名思义，当确定代理对象和被代理对象后，就无法再去代理另一个对象。</p>
<p>动态代理与静态代理的区别在于，通过动态代理可以实现多个需求。动态代理其实是通过实现接口的方式来实现代理，具体来说，动态代理是通过Proxy类创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>接口完成的。</p>
<p><strong>举个现实中的例子：</strong></p>
<p>静态代理就相当于：每多个房东就需要一个中介，这显然不符合生活认知（对于租客来说，如果是用静态代理模式，每当想要换一个房东，那就必须再换一个中介，在开发中，如果有多个中介代码量就更大了）</p>
<p>动态代理就相当于：不管是多一个还是少一个，始终只需要一个中介。</p>
<p><strong>动态代理基础知识：</strong></p>
<ul>
<li>动态代理的角色和静态代理一样，需要一个实体类，一个代理类，一个驱动器。</li>
<li>动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的。</li>
</ul>
<h3 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h3><blockquote>
<p>JDK的动态代理需要了解两个类</p>
</blockquote>
<p><strong>核心：InvocationHandler调用处理程序类和Proxy代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span></span><br></pre></td></tr></table></figure>

<p><code>InvocationHandler</code>是由代理实例的调用处理程序实现的接口，</p>
<p>每个代理实例都有一个关联的调用处理程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span>;</span><br></pre></td></tr></table></figure>

<p>当在代理实例上调用方法的时候，方法调用将被编码并分派到其调用处理程序的invoke()方法。</p>
<p><strong>代理：Proxy</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-实现动态代理"><a href="#3-2-实现动态代理" class="headerlink" title="3.2 实现动态代理"></a>3.2 实现动态代理</h3><p>1、首先是我们的接口类：<code>Say.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DtProcxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Say</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、然后需要连个实体类去实现这个抽象类：<code>XiaoHong.java</code>、<code>XiaoMing.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DtProcxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoHong</span> <span class="keyword">implements</span> <span class="title class_">Say</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小红说她想要一个苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DtProcxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMing</span> <span class="keyword">implements</span> <span class="title class_">Say</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小明说他想要一座私人飞机！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、动态代理实现类：<code>UserProxyInvocationHandler.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DtProcxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserProxyInvocationHandler</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理代理类实例，并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 选择过滤要执行哪些方法</span></span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;add&quot;</span>) || method.getName().equals(<span class="string">&quot;delete&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有什么可以帮助你的&quot;</span>);</span><br><span class="line">            method.invoke(obj, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;当前方法执行结束...&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行了意外之外的方法...&quot;</span>);</span><br><span class="line">            method.invoke(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、启动器：<code>Client.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DtProcxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">XiaoHong</span> <span class="variable">xiaohong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoHong</span>();</span><br><span class="line">        <span class="type">XiaoMing</span> <span class="variable">xiaoMing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoMing</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面就是使用代理来执行代理替小明、小红说话的过程</span></span><br><span class="line">        <span class="type">UserProxyInvocationHandler</span> <span class="variable">xh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxyInvocationHandler</span>(xiaohong);</span><br><span class="line">        <span class="type">UserProxyInvocationHandler</span> <span class="variable">xm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxyInvocationHandler</span>(xiaoMing);</span><br><span class="line">        <span class="type">Say</span> <span class="variable">xiaoHoneSay</span> <span class="operator">=</span> (Say) Proxy.newProxyInstance(Client.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Say.class&#125;,xh);</span><br><span class="line">        <span class="type">Say</span> <span class="variable">xiaoMingSay</span> <span class="operator">=</span> (Say) Proxy.newProxyInstance(Client.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Say.class&#125;,xm);</span><br><span class="line">        xiaoHoneSay.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        xiaoMingSay.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/images/daishen/img/65.png" alt="image-20240625123023462"></p>
<h3 id="3-3-在反序列化中动态代理的作用"><a href="#3-3-在反序列化中动态代理的作用" class="headerlink" title="3.3 在反序列化中动态代理的作用"></a>3.3 在反序列化中动态代理的作用</h3><p>假设存在一个能够漏洞利用的类B.f，比如Runtime.exec这种</p>
<p>我们将入口类定义为A，我们最理想的情况是A[O] -&gt; O.f，那么我们将传进去的参数O替换为B即可。但是在实战情况下这种情况是极少的。</p>
<p><strong>回到实战情况</strong>，比如我们的入口类A存在O.abc这个方法，也就是A[O] -&gt; O.abc；而O呢，如果是一个动态代理类，O的invoke方法里存在.f的方法，便可以漏洞利用了，下面为展示整体思路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[O] -&gt; O.abc</span><br><span class="line">O[O2] invoke -&gt; O2.f // 此时将 B 去替换 O2</span><br><span class="line">最后  ----&gt;</span><br><span class="line">O[B] invoke -&gt; B.f // 达到漏洞利用效果</span><br></pre></td></tr></table></figure>

<p>动态代理在反序列化当中的利用和<code>readObject</code>是异曲同工的。</p>
<ul>
<li>readObject方法在反序列化中会被主动执行</li>
<li>invoke方法在动态代理中会自动执行</li>
</ul>
<h2 id="四、Javassist动态编程"><a href="#四、Javassist动态编程" class="headerlink" title="四、Javassist动态编程"></a>四、Javassist动态编程</h2><h3 id="3-1-Javassist简介"><a href="#3-1-Javassist简介" class="headerlink" title="3.1 Javassist简介"></a>3.1 Javassist简介</h3><p><strong>动态编程</strong>是相对于静态编程而言的一种编程形式，对于静态编程而言，类型检查是在编译时完成，但是对于动态编程来说，类型检查是在运行时完成的。<strong>因此所谓动态编程就是绕过编译过程在运行时进行操作的技术</strong>。</p>
<p>一般来说，在依赖关系需要<strong>动态确认</strong>或者需要在<strong>运行时动态插入代码环境</strong>中，需要使用动态编程。</p>
<p>Javassist中最为重要的是<code>ClassPool</code>、<code>CtClass</code>、<code>CtMethod</code>以及<code>CtField</code>这4个类。</p>
<ul>
<li>ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</li>
<li>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得</li>
<li>CtMethods：表示类中的方法</li>
<li>CtFields：表示类中的字段</li>
</ul>
<p><img src="/images/daishen/img/66.png" alt="img"></p>
<p><strong>Javassist使用流程：</strong></p>
<p><img src="/images/daishen/img/67.png" alt="img"></p>
<h3 id="3-2-代码实现动态编程"><a href="#3-2-代码实现动态编程" class="headerlink" title="3.2 代码实现动态编程"></a>3.2 代码实现动态编程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TestJavassist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDome</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成class字节码文件</span></span><br><span class="line">    <span class="keyword">public</span> ClassPool <span class="title function_">javassist_make_class</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取默认类池</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//创建一个类ClassDemo</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;TestJavassist.Test&quot;</span>);</span><br><span class="line">        <span class="comment">//新建一个int类型名为id的成员变量</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(CtClass.intType, <span class="string">&quot;id&quot;</span>, ctClass);</span><br><span class="line">        <span class="comment">//将id设置为public</span></span><br><span class="line">        id.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        <span class="comment">//将该id属性分配给Test</span></span><br><span class="line">        ctClass.addField(id);</span><br><span class="line">        <span class="comment">//添加无参构造方法</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public Test()&#123;&#125;&quot;</span>, ctClass);</span><br><span class="line">        ctClass.addConstructor(ctConstructor);</span><br><span class="line">        <span class="comment">//添加有参数构造方法</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">ctConstructor1</span> <span class="operator">=</span> CtNewConstructor.make(<span class="string">&quot;public Test(int ids)&#123;this.id=ids;&#125;&quot;</span>, ctClass);</span><br><span class="line">        ctClass.addConstructor(ctConstructor1);</span><br><span class="line">        <span class="comment">//添加普通方法1</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctNewMethod</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void calcDome()&#123;java.lang.Runtime.getRuntime().exec(\&quot;cmd.exe /c calc.exe\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">        ctClass.addMethod(ctNewMethod);</span><br><span class="line">        <span class="comment">//添加普通方法2</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctNewMethod1</span> <span class="operator">=</span> CtNewMethod.make(<span class="string">&quot;public void hello()&#123;System.out.println(\&quot;Hello World!\&quot;);&#125;&quot;</span>, ctClass);</span><br><span class="line">        ctClass.addMethod(ctNewMethod1);</span><br><span class="line">        <span class="comment">//将class文件写入磁盘</span></span><br><span class="line">        <span class="comment">//转换成字节流</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">        <span class="comment">//写入磁盘</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">classpath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(System.getProperty(<span class="string">&quot;user.dir&quot;</span>), <span class="string">&quot;/src/TestJavassist&quot;</span>),<span class="string">&quot;Test.class&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(classpath);</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classPool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行class字节码文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">javassist_exec_class</span><span class="params">(ClassPool classPool)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        ClassPool classPool = ClassPool.getDefault();</span></span><br><span class="line">        <span class="comment">//获取javassist的classloader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>(classPool);</span><br><span class="line">        System.out.println(<span class="string">&quot;loading&quot;</span>);</span><br><span class="line">        <span class="comment">//加载新的class文件</span></span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;TestJavassist.Test&quot;</span>);</span><br><span class="line">        <span class="comment">//反射调用函数</span></span><br><span class="line">        clazz.getMethod(<span class="string">&quot;calcDome&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">        clazz.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>).invoke(clazz.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">TestDome</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestDome</span>();</span><br><span class="line">        <span class="comment">//生成class文件</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> test.javassist_make_class();</span><br><span class="line">        <span class="comment">//执行class文件</span></span><br><span class="line">        test.javassist_exec_class(classPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/images/daishen/img/68.png" alt="image-20240627102025004"></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>Javassist</code>可能存在的漏洞点还是在于反射的利用、使用<code>ClassPool</code>生成class文件的过程中，如果存在参数可控的话，也会造成代码注入的漏洞。</p>
<h2 id="五、获取Class对象"><a href="#五、获取Class对象" class="headerlink" title="五、获取Class对象"></a>五、获取Class对象</h2><p>Java反射操作的是<code>java.lang.Class</code>对象，所以我们需要先想办法获取到Class对象，通常有以下几种获取方式：</p>
<ol>
<li>类名.class</li>
<li>Class.forName(“java.lang.Runtime”)</li>
<li>classLoader.loadClass(“java.lang.Runtime”)</li>
</ol>
<p>获取数组类型的Class对象需要特殊注意，需要使用Java类型的描述符方式，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; doubleArray = Class.forName(<span class="string">&quot;[D&quot;</span>);<span class="comment">//相当于double[].class</span></span><br><span class="line">Class&lt;?&gt; cStringArray = Class.forName(<span class="string">&quot;[[Ljava.lang.String;&quot;</span>);<span class="comment">// 相当于String[][].class</span></span><br></pre></td></tr></table></figure>

<p>获取Runtime类Class对象代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br></pre></td></tr></table></figure>

<p>通过以上任意一种方式就可以获取<code>java.lang.Runtime</code>类的Class对象了，反射调用内部类的时候需要使用<code>$</code>来代替，如<code>com.anbai.Test</code>类有一个叫做<code>Hello</code>的内部类，那么调用的时候就应该将类名写成：<code>com.anbai.Test$Hello</code></p>
<h2 id="六、通过反射执行命令"><a href="#六、通过反射执行命令" class="headerlink" title="六、通过反射执行命令"></a>六、通过反射执行命令</h2><p>普通反射执命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">runtime</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> runtime.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> runtime.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">m2.invoke(m1.invoke(runtime),<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果WAF拦截<code>Runtime</code>关键字的话，就转出字节数组的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Runtime</span></span><br><span class="line"><span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span>&#125;;</span><br><span class="line"><span class="type">byte</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span>&#125;; <span class="comment">// getRuntime</span></span><br><span class="line"><span class="type">byte</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">99</span>&#125;; <span class="comment">// exec</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">runtime</span> <span class="operator">=</span> Class.forName(<span class="keyword">new</span> <span class="title class_">String</span>(arr));</span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> runtime.getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(arr1));</span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> runtime.getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(arr2), String.class);</span><br><span class="line">m2.invoke(m1.invoke(runtime),<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><p><a href="https://www.freebuf.com/articles/web/335236.html">https://www.freebuf.com/articles/web/335236.html</a></p>
<p><a href="https://www.cnblogs.com/yokan/p/16102570.html">https://www.cnblogs.com/yokan/p/16102570.html</a></p>
<p><a href="https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/#Javassist%E7%9A%84%E4%BD%BF%E7%94%A8">https://kpa1on.github.io/2022/04/27/Java%E5%AE%89%E5%85%A8%E4%B9%8BJavassist%E5%8A%A8%E6%80%81%E7%BC%96%E7%A8%8B/#Javassist%E7%9A%84%E4%BD%BF%E7%94%A8</a></p>
<p><a href="https://www.javasec.org/javase/CommandExecution/">https://www.javasec.org/javase/CommandExecution/</a></p>
]]></content>
      <categories>
        <category>代审</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>悦读</tag>
      </tags>
  </entry>
  <entry>
    <title>破解HEXO加密文章</title>
    <url>/2024/07/28/%E7%A0%B4%E8%A7%A3HEXO%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><blockquote>
<p> 因为<code>Hexo</code>大部分都是居于<code>Github</code>的静态博客网站，所以它所有的数据交互都是在前端进行的，那么对文章限制输入密码校验后才能访问密码也是在前端进行的。</p>
<p>破解思路：居然输入密码限制访问是在前端进行的，那么我是不是可以进行抓包进行JS分析，然后修改JS代码进行绕过呢？</p>
</blockquote>
<p>说干就干….</p>
<h3 id="二、Burp抓包绕过"><a href="#二、Burp抓包绕过" class="headerlink" title="二、Burp抓包绕过"></a>二、Burp抓包绕过</h3><p>目标URL：<img src="/images/NX/4.png" alt="image-20240727170619237"></p>
<h3 id="三、-打开Burp"><a href="#三、-打开Burp" class="headerlink" title="三、 打开Burp"></a>三、 打开Burp</h3><p><img src="/images/NX/1.png" alt="image-20240727170108998"></p>
<h3 id="四、-走代理"><a href="#四、-走代理" class="headerlink" title="四、 走代理"></a>四、 走代理</h3><p>打开浏览器代理走Burp，访问目标URL</p>
<p><img src="/images/NX/2.png" alt="image-20240727170245520"></p>
<p>右键抓响应包</p>
<p><img src="/images/NX/3.png" alt="image-20240727170334303"></p>
<h3 id="五、-抓包"><a href="#五、-抓包" class="headerlink" title="五、 抓包"></a>五、 抓包</h3><p>抓到包后，搜索“密码”，然后删除<code>JS</code>校验片段</p>
<p><img src="/images/NX/5.png" alt="image-20240727170723641"></p>
<p>删除JS代码片段后的数据包是这样子：</p>
<p><img src="/images/NX/6.png" alt="image-20240727170803882"></p>
<h3 id="六、-绕过成功"><a href="#六、-绕过成功" class="headerlink" title="六、 绕过成功"></a>六、 绕过成功</h3><p>然后重放，成功绕过<strong>密码访问限制</strong></p>
<p><img src="/images/NX/7.png" alt="image-20240727170948794"></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>逆向</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVASE基础-1</title>
    <url>/2024/07/29/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4f03a5e4870a8aa22cb3692eaa079d0c171bd02bab8c1be0b20d8c52ef559642">1d621d107eecb08cb114bf54a2314bea723a2c7b8164d6013b25394e581f3bffac4cc7ecfb41caaed4d01b4f6e0645fe1671df0dd10b5009a3816c2047e2fd009cb4887462e46d70d4b8f4e844032f4b94413c4f29d6421fbf4ee1b1faafb1040cdd534054977337850a287ad362cd567b2cb9ae68266a96b4259b9c9609b0acad7a9833e893b2a6985ce1379231efe43faa14bb6c13e7128231bb045903a0ce6c4e15f56193e334edb73a92485941ba350d912060ca1dc071e0bd5854e7abc31d6a04273b5ca9e39910d4e46e33bc5ad4219129fadcd24456fcf8678d416462ed756502730dbe3a44d8e129989ba0355813b86d19e1805cd0c376e801d85ebd84e2e85e7f21fb08b33a95cb114ccfeac734695ad7664b1d5dd883a9c3561a9e63943865eb8f53ba342ab07dc42ed8edd7cec4b1ba5795b3564c901d1ebed4f98ba0ca35a3d622608ed0f605cb99dbc562bf0d4bd08eb312ee1f838f58138f0a24dcfc2936ded7270dbbab8b158cfe1c4bf4e19545941761ac7f94f0742b02391aa606dade89ee6a9a282b20159307a1cd80634ed5333e6b1d82cb981945145d089018c73cb04997b900a62490b7314deed83ef98e7d2a2ca0a7ce95c67fa5659ef4e0c0383e09eab8621ad89cded3887749f7bf1f425a1cb70dc44721c1ccbbde3afb496bfcfec149659725929d20925412b7a85bd457be0c12a3a13c7ae368df2d4a1a38cbb73fb2df23494027699ea8c6b8fe1d71ac8a30ef6c5d9d5ff3dae122c6c815afe3ad029be043522ed1a38c8acfc9927ddce98549ac41c5412c0e51725d8bc56fb7f65c4912199623d1b92b5b31909056fd4d689751ebe7d254e8d6e9251e0460d8c0da21e4738bf67280645f57803241ad25e5674efcb4648e09f2f5290711511bd6c18775c4d8ecf765ef453224666bdc4f602de486d4ba8006961873c3b1ac756147c02f15e8f485c9dfdac5f3626aee7b03418bcf18f6509cfde20f68c82458c6321e543e9f4678cc1739a60c273c35ccbb49b0dcfa29cbd4c4fbb2a938116caffe8614da152b240f4ed084c34a0095840721a86b34129d092f10b513150f72eb2651b3a1628b3f8bce4ba00ee5943896fdcbb2616b09bfa074166e5ab517982c362ee9bcb91ed8ab2cd291c9519aace6b21f307d56af4419a47b82073eb7b957f93bcc5ed819b704c15a15ac31c457995a9ba586dd4ef7822baa534253626ef0d4bd18b08a72953945483ff585cf3530116bfedae802306526330cb3fa9eddbc507970ba72ce8b3994639e09dc8da6a53c0b409fa49b69ee895662398d4311fedfdb73d313c704074312ec2ae288e06f7188a8aad30346a49b36690adf36c60f328d057cf13681a7c4d5c4a13e8bac9c418569b97320018a078050528f4ec96b6ebb2a84930ed25e508f9eab0ebcd4f157f102444ec259ea4673c9031702fd8672a69104868290ac7e858c1ac244fb7c4b0b907d187b75593da47e7b26d7654aeed8f8d3f42b6597373d7cc832c26fbff9afa52e6dae69b34ad515df02997ba4aaa84ec7906403f90cfdcde2cb4d04026cfe4adc249f24b196de834b3622700147250a45e29c636c49bfb956345348bd1edb534e0d8d54084f0df1caa1c17948577ca59ab5e837810bac96c4060c15aa3db0e111970f74c5f0471e813ea8094b0060a827ad41336dc1af3cb60445d4c25e3301653bceeb0aaa084091dbaf23f05b6b68c2a69551a6941621c720180f2c58f87af9162285e1beb3a970cfdc9f547828a7df9afc2ecec47b3436dd97f86f326b567b91c86bca82f6e344367fd92d3326998bf9c8d26a5044a2580f99d4576e9a5ec30136e8552aba8d2402fd6d5ce470f98ac9aa2ded81ef29ff8e3a7c63497234c0a1ac0a1b41c6290ff37ee2a3b26822b0d89e47443a67603d2bccb492ea94f41ba0bb265d36b7c9b9156cb679ba5dc7f8fddcd1559a063924a18f8f6ac057bccf40bd840e60d01b5f6892d669866d6e6c8b863f59dd785fb7c7286496e6d2252b0e2146c556f3ef9b6751239989987532f43bd1716ec3b2f920074938f44bb1cb4c11655c3ced12310c570ec6559d0401af9b23742eeac20122048c782c66ca9505ffa60102a65fe02fbff7787d1bd64d6701c8f7c4f76a594834d10dd1bbb78e6872dbed6759ac05001058dbcdd6f3b700ed1519256787df2de38c13debfd11d2cf49d1ba26bade74699e03e50e863a1f28e2dc790ee0aa9e988ce0470dea6cce3331627f0539d11b7df2e755c919be39a8653c667bd7a5cf1d690cc10848ece2c4a9ef02cdd1fc4deb3eb4a87484247a36475721fc32da4c3de3d10f7d70251065bbf55895c3d1a1a70ba3da2986800d651bea054e1ee418834139fb9b37dada8d08e3078da18c3693195fd49a62b3ecda65ace6445fdd66080bb12d55a9e8acb6d1f43ae444edaf8be03127cb4d476bcfae07a296307159328b23e5d210cb4832d2744fa0575643369cf2b2d92c7b2d9d68b5552c62c029769b3c7c23e7dc9a9aa7f5e539f74b4c1ea93e5522d24edaf655db3cea1af6541992b4b22c425f408cfd2c55ac2064e43b330dcca3b6ff96cd65377e30b17b372af43f405bd9ebb9de769b187c01178086a328dbecbe7a9ea772a684fd208326ffe5b89d85d273757d5f3eb0cf6abd632ad4f46f15f7463c33d3ca244123eb8d7778a414f6c8114e041d87f76b80fdec6f13772125af3be12f828d8cdc1d6236ebc1c95e046054e54ef50e633ac6430672ac230556dbaba9b7de654eab0a488582e4623011715ee610f5be0ce5dc518630bbf49e55e022b958b9333decc5c800f53f3b7ecfd9f8090c1b3b24f8bc9cd95e7947cf80a092884f104c5dfd1b1d4999aaddef93dcf50b8f91c8ffc0ba4f20efdbe7530c277f1dd27a32cd6cbd856661745c8768e8628f94336ea3ab4ade0f55d33676c7671f4b96532137ff3a5f0df9ea6190faeb88c1d6bcda3c5240fe81f1a3155cd8eefe285766e09a4065362bbc9ec46e44c5c7128200b521582a655e9c982203b24027f3a6f85d97a40c17871939c4c775116ba16210274ee6a4b0650fbac96893a4eb7464b0a5a90d1d070cc9aacd14af85cebd5dc52969fce2d62c3f13095b1009a081c3ab3157b0918b6ad890a053270f1c5a39c9f8d0a6f8792ded1b623d08439a07c15ae61cceb7732ff691bbdf96896860046bb7ab6c492f141c9fa7bf939ce4f8fcd39eb912bd968b78665b4c386097e2db784d565c8d4290d45841f0642650864dd9ab36c3ddd69379a0b47ec94540b2b68c3b1406d1b3a4e7a248edec1bf760800033345819fd01f2d877b119ec61af770c73b147ded7430208e2ed605256754185c6a77209d3b0a6115fcb80953080171841c3d813a23832ecd3e99718d260327b95a59e91f10d152ec3a97c3da495d4300dcbb49bbb55dbc7913b67e02d832f6d4137c47abc6772df15e5456229c058260afaebd1d705c45c5e072a4d32101cefa489aad9a3ca8b930ff368fa9afeabde06446d129281ea278a110e0a792b7ec45ae49dfd3f97d3ef1371676918dd074287b3576f42da130434a54e552aa61ed8804ee68b961ff963a7ef7d514d69fd6a447805928f9c4ac7a55bbedb56250a0212fd918b9d9cb753448871f5ba3b20af3fdc6a8e33e0a7e6e213c764f0ae3712cd47936e41dcf4c2c898025ee46e9a4074894df40cd91919c44c7fbeadbe3d80fafdb75c8299782a1e78c894ea2e7bb8f29ed1573979ebd1337f6d198ca1aada8951c1dd7335d2d9ee1ef07ca8aa431a6b85f1d15587ebe45d1f92b77bd9445f34c577aab544814eb7b7713b3742a496d1b83dcc4898003738000c673d541b485521ac63ba846eb77a770929b8e79d687c5fb0148080c6222c5b978ab2df851cc0c668b8fae35f1cb12adf2e364e4901e5f3644eb33d5b7af58bfdde2a62cf9599dbb9cfc6ea467f76a4a5cbc3ebb504456dde079a7cedf3845511ccc55e8cbde037fb3d3fdbfd3b2097b6a07c369b7e12826aae6a8c0087f3f1eedc1625b6ce80165d1b036f9e262c4d709987c6afab54d03cf52be22cd39df311f23576998853d9aba3db29a1104d1f3eb71435801e40cbc31563826119a2fb09f62e9fbad8f2bd20cbb14ad1f79ee7002cf5f2c6f7efac4cd403dc8185c537f0e5b45aeb4ebb64960dc052b8e04147caa9044154002dee3e395eece4240118f3ce9c558781750c5bc493a33cf06dceb24ff24a96da2342ca8cac8552217ae9dc0284d821e93b5f1bef5dbcaf64bb6bdcc1f9efa63aec2f188f8d02a10ca3bef4c528ff1cc63edff215a0d82a1e9dfeaf7ac966bce0e8274e5e3dba8c9d3de8d54cbdf32365da61345b5499fef09c77f86a657b802ede22f903f25ddd7324faee53eee945212d20245d370a177bf79a9248be648d2ffbb6dd12e54936da4976ba09bb9629ea8a32dce06b34997009537f11a95543b538dde95a3bde3e156e81095dd3cc6d97968c521e472ab574b3e0a16c132d7686d28d8de796151b29ac5eb094bb5d77ba9e643d1624b66809a99d63fbb9df8774e1de98063436e0f49b7912f9eeee470cc1d545f890b5120f328ef1fc04c1dc4cef0876a44bfd1da92f4f135e35b6b983edeaa3336c94a559e291714efe1e93180e599eae24ec2b610c511d5222518310fddb53c91f74dad92f0ff116bced4183cfc4a0cd875cbfbfdb9859856b9923e9b307927390481d6f90e6c5fa3639d428436482f28a6df338c2ae2eefe440cb8bf6e7fbe29d22e3c86c693029e58b97508688e46ec6187c7259c43126f32927d74dd046cfcd2c44759a4655035bc33eddc63e797d709864b19c4b8b19720ce4a524ca3346e51ef0d49d8406367244bb80de4afc50edba146fa0d033bba400d2cea4e22b63e6a2f5cf83c9309fcecc109dfc6e453223c090ad104044b09ef3c7c57fc45f38b7aa3dd6f8839711607eb7bc686cc0957bdffa66a66d01ff58694182ef7e7469c58afe8b1a8c17776f011c6e2c322ed8e2f9d91f9e2c524307740c93404fe8886d20f36c9a7ee53a4228d7c25f79f219acfbabfaca098142b4d1b5c975c90b3c9a2d88c3155ac180fb5f549bd2531911141a786c0f00486beaa20aa3261fb3dc3ba3250ba2a508102d322e220038fcc19851ba420409d971ce22097267fe7e893173b88a77d485493aa3165b0a58699eb888b3139088d77d6308d45ee19b005a25755a7d2e16bd2db1856334c822a840dfd57c9a3bcd9347439f266f14dc4f49b59ce5f08fc9065597d2cfdfb60ddd6e6aec2b8e71b52c629bf152c6127575daecc1063cdffde2158fb76fcda8d1a6ccf387c818b151b5be429dc4963d7815c39e6929352c3b8aade83e2e51ba992efde264ecb56ed81306dda73614bf3b5ffe3a519d5615067f6588c380bec0f9d3c24f5acf1200ee4d52334069fa23a1070a824ed0f5aa711da0a9e8a570401d349ed5a90009ad0e64e17ab24b7cef540549f156849830d89a2a56ed149be7e2e630e74c445fae343bbd673fcb2ee973fd924945374c651d94acfa0d62696061d61b04b43c7910afcf05eb8a07108d0814e114b4a58a4ad7216bb119b9ee3bcb552fda6401ecf79ab4c335b41375ceed8368d0dc86826713a4f71b1ed8fc02fd4e010ac8fbc96163dfe5e65ccdfa5a2964b59409f2633674a9cee64ba7e97a1fba9ef6be114103111bfbe7b1bf31399572d61c3d1f0a63ed38f2b74ed9b95bddcf861f7177ad62998691618a34e09e2b5bcfecd47de05b4934fb6bcc6abe6fe954998c305a994a7403dbd66bfadc27f4e10cb7623e54319e88e34faf19e7c5d86c5593de503a57a22004a6201c9a0e4742a3265ff324a2dbe20c45005790aaa0c9f14bfb1a24ed90df521d26ef125b1894c187fb797c3aa20c3764f9b8a2b692f39b719bcf3554b119c06d8d796ec4f766b3b07ee5fbc6b5e303d2b3b689364cd37716eda68213a88e5614dc4c9ee421106fbe3464479c6edf7aaa55d9cefae40ecfacb16359965e92a80dd13a4e8b9821d62f7b3d736759af07dc02d5daab0f3845881fc523fcddd5b68557e8ee0056148b6477f52064f2f0cc0bf10d977eb749542fadb149e989ce378340890df9d00fb14d0fb907789b5f5a31e42855ce1eac862a1dc403f56986356e12ee7baf5cb816338a0b86d3e5f5bf71a183ef0a8924c97e9ca06ba609de51edccb8c5a1797909dad62f1bbcd5bfe9995cbe605bd9d030fd09173f8c4e4f9ec55b50751ea5beacd5f38672eba11f0968131b4934110137208fc252cf8f1ad6d1845712bab9aef9a53beb9dcc513b4e8cedfaa00013b6b9295d73315b779fd415695fad5c1bf4d76afe21c967833ccba62c93b0ae63c2c118d25573ef1d65163a230837c7c8ac7ff88e1b7dcd499ff1e0313141cb7b5a24729ff5569b2f9e333632f575c5629b2883672d3e62099bb5f11a8ed965a47e60ed6286d4bb41c035529b8c6f7923c0d55294166580bb5d7bc9f5ff3793b16b65424014f41cd9c35cc60fb1d4ac8cf2d84a0b406229b47a7d2cd16188af189a906d8baa9a4a1b6148bfac797f9c62a5f9500201c54ddbc173639c3ab034a967fb944f8f8a888ec6c85e44bc7336fb19b8baa24a4298c215165257ed943dba00c9efdda5263f0b35090699585b85e8e21d384aaa3dedd038d918e01a0fe9d4c60aa0b5d1535aa353e7c9ec4c75a16f31da6eaac8dce3e8a58606484cd04e0294269d65779c7f9815849ba6138d0a7f266fa0c1bdc37b2620ac0510d0b971792e0c32e35b613a7479b8f0d0fd28ddc6fa102c5d28f647455d07d1f719d5a749903715266d718ff72459853cba4ec9a9853902f55beca3a8f8b9616afe2f262a3067883589b19c324eebfced37af11d9f02f54f73e6895b305d793bd73dec66f48dff674db5e921e31501e43843fed4297c15aa0f2d75c8900c692a9ce2e2b13bfeb031bd93d752edc0685ef0f3a5fe199bbaaeab609693438838359ee36301932e1888331b91b578cfe112118ff4da795191151e48ec10f67c761e880c4371a71c716df41d2c72be41ad604c05a75865dbc8098b4399dfe51a2a7f5b10f31aefa4322abb07b111d82abe6beafdcbdc477baca0950568851f585b04c5a7b729d7aff9dca2103e51cf35495487c56a73c695a60ed49a4ec770a3165b4df7315158f5acff9b89ee878287310a3807f8e3ca161abe30f0b5a18c2dd1002fd75252a2dc527d78a6cb31384f9b7eae33f966ad274411fb0db68fa29b7c865e8120cb263c6e153af92c6692570b83e03338326ef76f3d8fa5db8a63365773471d7f33cd4c3d8485aa842de332c4e10a87a891002bb559d65f843c0d66acb0fa033778f094f7cb57aa3b20e4337d9936ebf619261dca519a5b89247e68185688655bec9a2c8af29f95585d888c68a0711c2e0cb5b4fed8f50887fb049e195de97ce041e96c14f9e581b0d38cb90aadd8141f27d2a0df173544f4eb7e466bcead3033ba45fca6ee0fabdc6250caef19a12c2f8244aa06cfe0d617e4bc1e46856ad1a2848bbf3ba99b114a4288b62afab8df078ab0da80ab36c2937639aeb2b8ee51509a74f61928a21bd182c1621741a445bfa9fb11a280dc021099a923ea89fa900cd08462e4665115e836e5cbdc19e15de2e0b9350d67e89fec0479dc9deed5ead193839f325ef120a8dd6f4cf4e9addb11bee3fbe941749ba69f4b78b895d468786ad29a04ff91450b6bf83184b33e7cd1080642935fb2219d4edc27541b75a584b47a541b89436dcb10b82ea220d19d868c2141d068cc4300eeb6dcf177e4abf52c448df62653eedb33536fb91b8307b426d770cb5982f28c05db65e9b8eb08e921845690918de4a6a3d49fe1cbb0c5d2a4a224bec465b546fd5ad8f9242fbf06191a1c2a320d8fad8aa91298ac8dd0bdf2113cc9519097830725f3b274c8537490e58b7f41597a27507aa79d60b42b1f7935223021c97eae23729ac3d6bc2f51e6aa1fb65cba3583658e2a08df63c512a84f66364332f4f0085e98e10ed49de6d128152c777e5ebe83193745748083b3bd9955d1b64851180bd7dd85934f959f05059c795e25f6b18112e21d573131e060afbefd20d30c9632fca2ab331be5090de59ceb432409c91f6c0617af5d777e751216bdd12ab51044f7ea91ecae9f0d6fbf20a60c4f0d2018a9a18895f9232c39e62623df599c650bda887e9a7bdc7484426d972798d2debf39869f561d421ba57a0bb2e4635a9b388d4db49d2b8a9e2bef4b0bea03b06b9b1dacd3f4f5956198e0569f35587f30c63e40b3dffd23f7ef8c7b6b6e23a604780e3137d30f521c0393afc61f4fb2393f0d8a286aa60e202d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>悦读</tag>
      </tags>
  </entry>
</search>
